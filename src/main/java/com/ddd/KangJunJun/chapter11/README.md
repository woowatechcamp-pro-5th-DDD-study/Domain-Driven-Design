# Chapter 11 - CQRS

## 11.1 단일 모델의 단점

주문 내역 조회 기능을 구현하기 위해서는 여러 애그리거트에서 데이터를 가져와야 한다.

주문 내역 조회 페이지는 로딩이 빨라야하는데 여러 도메인 모델을 가져오기 때문에 Select를 여러번 날리게 되고 결과적으로 느려지게 된다.

- 식별자를 이용해서 애그리거트를 참조하는 방식을 사용하면 즉시 로딩과 같은 JPA 의 쿼리 관련 최적화 기능을 사용할 수 없다.
- 애그리거트 간의 연관을 ID가 아니라 직접 참조하는 방식으로 연결해도 고민거리가 생긴다.

구현의 복잡도를 낮추는 간단한 방법은 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.

## 11.2 CRQS

CQRSCommand and Query Responsiblity Segregation  상태변경/조회 의 책임을 분리 구현하는 개념

![img.png](img.png)

명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있다. 이때 데이터 동기화는 이벤트를 활용해 처리한다.

명령 모델에서 상태를 변경하면 이벤트가 발생하고 그 이벤트를 조회 모델에 전달해서 변경 내역을 반영하면 된다.

추가로 데이터 동기화 시점에 따라 구현 방식이 달라질 수도 있다.
- 실시간 동기화(동기 이벤트와 글로벌 트랜잭션 사용)
- 특정 시간 안에 동기화(비동기 이벤트)

### 11.2.1 웹과 CQRS

일반적으로 웹서비스는 상태 변경 요청보다 상태 조회 요청이 많다.  
포털이나 대형 쇼핑몰과 같이 조회 기능 요청 비율이 높은 서비스는 조회 성능을 높히기 위해 다양한 기법을 시도한다.

- 쿼리 최적화
- 캐시 적용
- 조회 전용 저장소 따로 사용

이는 결과 적으로 CQRS 를 적용하는것과 같은 효과를 만든다.
대규모 트래픽이 발생하는 웹서비스는 알게 모르게 CQRS 를 적용하게 된다.

조회 속도를 높히기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분하자.

### 11.2.2 CQRS 장단점

장점
- 명령모델 구현할 때 도메인 자체에 집중할 수 있음
- 명령 모델에서 조회 관련 로직이 사라져 복잡도가 낮아진다
- 조회 성능을 향상시키는데 유리함
  - 조회단위로 캐시기술 적용 가능
  - 조회 전용 저장소를 사용하면 처리량을 대폭 늘릴 수도 있다
- 조회 전용 모델을 사용하기 때문에 성능 향상을 위한 코드가 명령 모델에 영항을 주지 않는다.

단점
- 구현해야할 코드가 많음
- 도메인이 단순하거나 트래픽이 많지 않으면 조회전용 모델을 따로 만들 때 얻을 이점을 따져봐야함
- 더 많은 구현 기술이 필요함 