# Chapter2 아키텍처 개요

## 2.1 네 개의 영역
표현, 응용, 도메인, 인프라스트럭처는 아키텍처를 설계할 떄 출현하는 전혁적인 네 가지 영역이다.

### 표현(Presentation) 영역
* 사용자의 요청을 받아 응용 영역에 전달하고 응용 역역 처리 결과를 다시 사용자에게 보여주는 역할을 한다.
* 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당한다.
* 웹 애플리케이션에서 표현 영역에서 사용자는 웹 브라우저를 사용하는 사람일 수도 있고 REST API를 호출하는 외부 시스템일 수도 있다.
* HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고 응용 영역의 응답을 HTTP 응답으로 변환하여 전송한다.


<img src="./그림 2.1.png">

### 응용(Application) 영역
* 표현 영역을 통해 사용자의 요청을 전달받은 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 구현한다.
* 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다.

주문 취소 기능을 제공하는 응용 역역의 서비스를 예를 들면 아래와 같이 주문 도메인 모델을 사용해 기능을 구현한다. 응용 영역의 서비스는 로직을 직접 수행하기보다 도메인 모델에 로직 수행을 위함하며 아래의 코드 또한 직접 구현하지 않고 Order 객체에 취소 처리를 위임하고 있다.
```
public class CancelOrderService {
    @Transactional
    public void cancelOrder(String orderld) {
        Order order = findOrderByld(orderld);
        if (order = = null) throw new OrderNotFoundException(orderId); 
        order.cancel();
    }
}
```

<img src="./그림 2.2.png">

### 도메인 영역
* 도메인 모델과 도메인의 핵심 로직을 구현한다.

### 인프라스트럭처(Infrastructure) 영역
* 구현 기술에 대한 것을 다루며 RDBMS 연동 처리하고 메세징 큐에 메세지를 전송하거나 수신하는 기능을 구현하고 몽고DB나 레디스와의 데이터 연동을 처리한다.
* SMTP를 이용한 메일 발송 기능을 구현하거나 HTTP 클라이언트를 이용해서 REST API를 호출하는 것도 처리한다.
* 인프라스트럭처 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.

<img src="./그림 2.3.png">

도메인, 응용, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않고 인프라스트럭처 영역에서 제공한 기능을 사용해서 필요한 기능을 개발한다.
* DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용하여 데이터를 읽어오고 외부에 메일을 발송해야 한다면 인프라스트럭처가 제공하는 SMTP 연결 모듈을 이용해서 메일을 발송한다.

## 2.2 [계층 구조 아키텍처](https://dev-coco.tistory.com/166)
네 영역을 구성할 떄 많이 사용되는 아키텍처는 계층 구조이다. 표현, 응용 영역은 도메인 영역을 사용하고 도메인 영역은 인프라스트럭처 영역을 사용하므로 계층 구조를 적용하기에 적당하다. 도메인 복잡도에 따라 응용과 도메인을 분리하기도 하고 한 계층으로 합치기도 한다.

<img src="./그림 2.4.png">

계층 구조는 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.
* 표현 계층은 응용 계층에 의존하고 응용 계층이 도메인 계층에 의존하지만 반대로 인프라스트럭쳐 계층이 도메인에 의존하거나 도메인이 응용 계층에 의존하지 않는다.
  엄격하게 적용하면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용한다.
* 응용 계층은 바로 아래 계층인 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라 스트럭처 계층에 의존하기도 한다.

계층 구조를 엄격하게 적용한다면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용한다.
* 응용 계층은 바로 아래 계층인 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라 스트럭처 계층에 의존하기도 한다.

<img src="./그림 2.5.png">

응용 영역과 도메인 영역은 DB나 외부 시스템 연동을 위해 인프라스트럭처의 기능을 사용하므로 이런 계층 구조를 사용하는 것은 직관적으로 이해하기 쉽다.
* 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 종속된다.


아래의 코드는 인프라스트럭처 영역의 Drools 룰 엔진을 사용해서 할인 금액을 계산하는 코드인데 응용 영역은 가계 계산을 위해서 DroolsRuleEngine을 사용해서 구현하고 있다. DroolsRuleEngine이 제공하는 타입을 사용하지 않아서 의존적이지 않다고 보이지만 DroolsRuleEngine을 사용하기 위한 특화된 코드가 존재하기 때문에 실제로는 인프라스트럭처 영역에 의존하고 있다.
* 인프라스트럭처에 의존하면 테스트 어려움과 기능 확장의 어려움이라는 두 가지 문제가 발생한다.
```
public class DroolsRuleEngine { 
    private KieContainer kContainer;
    
    public DroolsRuleEngine() {
        KieServices ks = KieServices.Factory.get(); 
        kContainer = ks.getKieClasspathContainer();
    }
    
    public void evalute(String sessionName^ List<?> facts) { 
        KieSession kSession = kContainer.newKieSession(sessionName); 
        try {
            facts.forEach(x -> kSession.insert(x));
            kSession.fireAURules(); 
        } 
        finally {
            kSession.dispose(); 
        }
    }
}
```
```
public class DroolsRuleEngine { 
    private KieContainer kContainer;

    public DroolsRuleEngine() {
        KieServices ks = KieServices.Factory.get(); 
        kContainer = ks.getKieClasspathContainer();
    }

    public void evalute(String sessionName^ List<?> facts) { 
        KieSession kSession = kContainer.newKieSession(sessionName); 
        
        try {
            facts.forEach(x -> kSession .insert(x));
            kSession .fireAURules (); 
        } finally {
            kSession.disposeO; 
        }
    }
}
```

<img src="./그림 2.6.png">

## 2.3 [DIP(Dependency Inversion Principle)](https://huisam.tistory.com/entry/DIP)
가격 할인 계산을 하려면 아래 그림과 같이 고객 정보를 구해야 하고 구한 고객 정보와 주문 정보를 이용해야 한다.
* CalculateDiscountService는 고수준 모듈이다.
* 고수준 모듈은 의미있는 단일 기능을 제공하는 모듈로 CalculateDiscountSerivice는 가격 할인 계산이라는 기능을 구현한다.
* 가격 할인 계산과 고객 정보를 구해야하는 기능은 하위 기능이다.
* 저수준 모듈은 하위 기능을 실제로 구현한 것이다.
* 고수준 모듈이 제대로 동작하려면 저수쥰 모듈을 사용해야 하는데 고수준 모듈이 저수준 머듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제인 구현 변경과 테스트가 어렵다는 문제가 발생한다. 이 문제를 해결하기 위해서 DIP는 저수준 모듈이 고수준 모듈에 의존하도록 바꾸며 추상화한 인터페이스를 통해서 구현한다.

<img src="./그림 2.7.png">

DIP를 적용하면 아래 그림과 같이 저수준 모듈이 고수준 모듈에 의존하게 된다.
* 저수준 모듈이 고수준 모듈에 의존한다고 해서 SOLID 5원칙 중 하나인 DIP 의존 역전 원칙이라고 부른다.

<img src="./그림 2.9.png">

저수준 모듈에 직접 의존했다면 해당 모듈이 만들어지기 전까지 테스트를 할 수 없지만 DIP가 지켜질 경우 대역 객체를 사용해 테스트를 진행할 수 있다.

### DIP 주의사항
* DIP를 잘못 생각하면 단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들일 수 있다.
* DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이므로 저수준 모듈에서 인터페이스만 추출한다고 DIP가 될 수 없다.

<img src="./그림 2.10.png">

### DIP와 아키텍처
* 인프라스트럭처 계층이 제일 하단에 위치하는 계층형 구조와 달리 아키텍처에 DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.
* 도메인과 응용 영역에 대한 영향을 최소화하여 구현 기술(인프라스트럭처)을 변경하는 것이 가능하며 DIP를 항상 적용할 필요는 없고 구현 기술에 따라 의존적인 코드를 도메인에 일부 포함하는게 효과적일 때도 있다.
* DIP를 무조건 적용하려 하지말고 DIP의 이점을 얻는 수준에서 적용 범위를 검토를 해야한다.
  <img src="./그림 2.11.png">

## 2.4 도메인 영역의 주요 구성요소
* 도메인 영역의 주요 구성요소

<table>
    <thead>
        <tr>
            <th>요소</th>
            <th>설명</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>엔티티(Entity)</td>
            <td>
                고유의 식별자를 갖는 개체로 자신의 라이프사이클을 갖는다. 도메인의 고유한 개념(주문, 회원, 상품)을 표현하고 도메인 모델의 데이터를 포함하여 해당 데이터와 관련된 기능을 함께 제공한다.
            </td>
        </tr>
        <tr>
            <td>밸류(Value)</td>
            <td>
                고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용한다. 엔티티의 속성으로 사용될 뿐만 아니라 다른 밸류 타입의 속성으로 사용될 수 있다.
            </td>
        </tr>
        <tr>
            <td>애그리거트(Aggregate)</td>
            <td>
                관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. (주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 주문이라는 애그리거트로 묶을 수 있다.)
            </td>
        </tr>
        <tr>
            <td>리포지터리(Repository)</td>
            <td>
                도메인 모델의 영속성을 처리한다. (DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능)
            </td>
        </tr>
        <tr>
            <td>도메인 서비스</td>
            <td>
                특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다. (할인 금액 계산이라는 로직이 존재할 떄 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건과 엔티티가 필요한 경우)
            </td>
        </tr>
    </tbody>
</table>

### 엔티티와 밸류
* 도메인 모델 엔티티와 DB 관계형 모델 엔티티는 같지 않다.
    * 두 모델의 차이점은 도메인 모델 엔티티는 데이터와 함께 도메인 기능을 제공한다.
        * 주문을 표현하는 엔티티는 주문과 관련된 데이터뿐만 아니라 배송지 주소 변경을 위한 기능이 함께 제공된다.
        * 도메인 관점에서 기능을 구현하고 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.
    * 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 사용해서 표현할 수 있다.
        * Orderer라는 주문자를 밸류 타입으로 주문자 이름과 주문자 이메일을 포함할 수 있다.
        * RDBMS의 엔티티에서 밸류 타입을 제대로 표현하기 힘들다. (정규화 하여 주문정보와 주문자 정보로 분리된 테이블을 구성하거나 반정규화하여 주문정보에 주문자 정보 컬럼을 함께 구성)
          </br><img src="./그림 2.15.png">
* 밸류 타입은 불변으로 구현하는 것을 권장한다.
    * 엔티티의 밸류 타입의 데이터를 변경할 때 객체 자체를 완전히 교체한다는 것을 의미한다. (기존 객체의 값을 변경하지 않고 새로운 객체를 필드에 할당)

### 애그리거트
* 도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현하고 엔티티와 밸류가 많아질수록 모델은 점점 복잡해진다.
* 도메인이 모델이 복잡해지면 개발자가 전체 구조가 아닌 한개의 엔티티와 밸류에 집중해야하는 상황이 발생해 문제가 생길 수 있고 도메인 모델은 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는데 도움이 된다.
* 도메인 모델에서 전체 구조를 이해하는데 도움이 되는 것이 `애그리거트`다.
    * 애그리거트는 관련 객체를 하나로 묶은 군집이다.
        * 대표적인 예는 주문으로 주문이라는 도메인 개념은 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액 하위 모델로 구성할 수 있고 하위 개념을 표현한 모델을 하나로 묶어서 주문이라는 상위 개념으로 표현한다.
          </br><img src="./그림 2.16.png">
    * 애그리거트를 사용해서 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라 볼 수 있다.
        * 개별 객체 간의 관계가 아닌 애그리거트 간의 관계로 도메인 모델을 이해하고 구현하게 되며, 큰 틀에서 도메인 모델을 관리할 수 있다.
          </br><img src="./그림 2.17.png">
    * 애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다.
        * 루트 엔티티는 애그리거트에 속한 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야할 기능을 제공한다.
        * 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 엔티티나 밸류 객체에 접근한다. (애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화한다.)
          </br><img src="./그림 2.18.png">

### 리포지터리
* 도메인 객체를 지속적으로 사용하려면 RDBMS, NoSQL, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관한다. 이를 위한 도메인 모델이 `리포지터리(Repository)`이다.
* 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다.
* 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
    * 도메인 모델을 사용해야 하는 코드는 리포지터리를 통해서 도메인 객체를 구한 뒤에 도메인 객체의 기능을 실행한다.
    * OrderRepository는 고수준 모듈이지만 구현한 클래스는 저수준 모듈로 인프라스트럭처 영역에 속한다.
      </br><img src="./그림 2.19.png">
* 응용 서비스는 의존 주입과 같은 방식을 사용해서 실제 리포지터리 구현 객체에 접근하며 응용 서비스와 리포지터리는 밀접한 연관이 있다.
    * 웅용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용한다.
    * 응용 서비스는 트랙잭션 관리하는데 트랙잭션 처리는 리포지터리 구현 기술의 영향을 받는다.
* 리포지터리를 사용하는 주체가 응용 서비스이기 때문에 리포지터리는 응용 서비스가 필요로 하는 메서드를 제공한다.
    * 애그리거트를 저장하는 메서드
    * 애그리거트 루트 식별자로 애그리거트를 조회하는 메소드
```
public interface SomeRepository { 
    void save(Some some);
    Some findById(SomeId id);
}
```
* 리포지터리를 구현하는 방법은 선택한 구현 기술에 따라 달라진다.

## 2.5 요청 처리 흐름
* 표현 영역
    * 전송한 데이터 형식이 올바른지 검사하고 문제가 없다면 데이터를 이용해서 응용 서비스에 기능 실행을 위임한다.
    * 사용자가 전송한 데이터를 응용 서비스가 요구하는 형식으로 변환해서 전달한다.
* 응용 서비스
    * 도메인 모델을 이용해서 기능을 구현한다.
    * 기능 구현에 필요한 도메인 객체를 리포지터리에서 가져와 실행하거나 신규 도메인 객체를 생성해서 리포지터리에 저장하고 두 개의 이상의 도메인 객체를 사용해서 구현하기도 한다.
      </br><img src="./그림 2.19.png">

## 2.6 인프라스트럭처 개요
* 인프라스트럭처는 표현, 응용, 도메인 영역을 지원한다.
* 도메인 객체의 영속성처리, 트랜잭션, REST 클라이언트 등 다른 영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원한다.
* 도메인 영역과 응용 영역에서 인프라스트럭처의 기능을 직접 사용하는것보다
  이 두 영역에서 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는것이
  시스템을 더 유연하고 테스트하기 쉽게 만들어준다.
    * 하지만 무조건 인프라에 대한 의존을 없애는 것이 좋은 것은 아니다. 의존을 완전히 갖지 않도록 하다가 구현을 더 복잡하고 어렵게 만들 수 있기 때문이다.
      (스프링의 @Transactional, JPA @Entity @Table 어노테이션 등)
* 표현 영역은 항상 인프라스트럭처 영역과 쌍을 이룬다.

## 2.7 모듈 구성
* 아키텍처의 각 영역은 별도 패키지에 위치한다.
* 도메인이 크면 하위 도메인으로 나누고 각 하위 도메인마다 별도 패키지를 구성한다.
  </br><img src="./그림 2.22.png">
* 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다. 그리고 각 애그리거트와 모델, 리포지터리는 같은 패키지에 위치시킨다. 도메인이 복잡하면 도메인 모델과 도메인 서비를 별도 패키지에 위치시킬수도 있다.
  </br><img src="./그림 2.23.png">
* 응용 서비스도 도메인별로 패키지를 구분할 수 있다.
    * 모듈 구조를 얼마나 세분화해야 하는지에 대해 정해진 규칙은 없다.
    * 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다.