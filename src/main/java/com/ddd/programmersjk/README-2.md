# 2장. 아키텍처 개요

## 네 개의 영역
- 표현, 응용, 도메인, 인프라스트럭처는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.
- 응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다. 즉, 로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임한다.
- 도메인 영역인 도메인 모델은 도메인의 핵심 로직을 구현한다.
- 인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다. RDBMS 연동이나 메시징 큐, REDIS나 SMTP를 이용한 메일 발송 기능 구현도 포함된다.
- 도메인, 응용, 표현 영역은 구현 기술을 직접 만들지 않고, 인프라스트럭처 영역에서 제공하는 기능을 사용해 필요한 기능을 개발한다.

## 계층 구조 아키텍처
- 위의 네 영역을 구성할 때 표현 영역 -> 응용 -> 도메인 -> 인프라 영역을 사용한다.
- 계층 구조는 특성 상, 상위 계층에서 하위 계층으로 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다. 예를 들어 표현 계층은 응용 계층에
  의존하지만 도메인 계층이 응용 계층에 의존하지는 않는다.
- 고수준 모듈(응용, 도메인)이 저수준 모듈(인프라)에 의존하면 테스트 어려움과 기능 확장의 어려움이라는 두 가지 문제가 발생한다.
  DIP를 통해 이를 해결할 수 있다.

## DIP
- 추상화 된 인터페이스를 사용해 Service가 인터페이스를 사용하도록 하면 의존성을 줄일 수 있다.
- 고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 한다. 반대로 저수준 모듈이 고수준 모듈에 의존한다고 해서
  이를 DIP(Dependency Inversion Principle) 의존 역전 원칙이라고 부른다.
- DIP를 사용하게 되면 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다. 실제 사용할 저수준 구현
  객체는 외부에서 의존성을 주입하는 방식으로 사용한다.
- DIP를 오해하여 구현 클래스와 인터페이스를 분리하는 정도로 생각하면 안 된다. 가령 RuleEngine을 인터페이스로 추출했다고 가정하자.
  Service 입장에서 볼 땐 룰엔진은 중요하지 않고 규칙에 따라 금액을 계산한다는 것이 중요하다.

## 도메인 영역의 주요 구성요소
- 도메인 영역을 구성하는 요소로는 엔티티, 밸류, 애그리거트,리포지터리, 도메인 서비스가 있다.
- 엔티티는 데이터와 함께 기능을 제공하는 객체이다. 또 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다.
- 도메인이 커질수록 많은 엔티티와 밸류가 출현하는데 애그리거트를 통해 개념적으로 묶을 수 있다. 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를
  묶어 군집 단위로 바라볼 수 있으며 큰 틀에서 도메인 모델을 관리할 수 있다.
- 애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다. 애그리거트 루트를 통해 내부의 엔티티와 밸류 객체에 접근한다. 이렇게
  내부 구현을 숨겨서 구현을 캡슐화 할 수 있다.
- 도메인 모델 관점에서 우리가 쓰는 Repository는 객체를 영속화하는데 필요한 기능을 추상화 한 것으로 고수준 모듈에 속하고 이를 구현한
  JPARepository는 저수준 모듈에 속한다.

## 인프라스트럭처 개요
- 무조건 인프라스트럭처에 대한 의존성을 없앨 필요는 없다. 스프링의 @Transactional 이나 JPA의 @Enitity를 사용하는 것이
  xml 설정을 이용하는 것보다 편리하다.
- 구현의 편리함은 DIP의 장점(변경 유연함, 테스트 쉬움) 만큼 중요하기 때문에 장점을 해치지 않는 범위에서 구현 기술에 대한 의존을 가져가는 것이
  나쁘지는 않다고 생각한다. 오히려 의존을 완전히 없애려고 시도하면 구현을 더 복잡하게 만들 수 있다.
